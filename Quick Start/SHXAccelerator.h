/**
 * \mainpage Description
 *
 * \version \$Revision: 987 $
 * \date \$Date: 2015-03-06 17:52:30 +0200 (Fri, 06 Mar 2015) $
 * \author Skyhook
 *
 * \page patents Patents Issued to Skyhook
 *
 * \li Dec 4, 2007: US Patent 7305245: Location-based services that choose location algorithms based on number of detected access points within range of user device
 * \li April 30, 2008: Singapore Patent 134837: Continuous data optimization in positioning system
 * \li July 22, 2008: US Patent 7403762: Method and system for building a location beacon database
 * \li Aug 19, 2008: US Patent 7414988: Server for updating location beacon database
 * \li Oct 7, 2008: US Patent 7433694: Location beacon database
 * \li Dec 30, 2008: US Patent 7471954: Methods and systems for estimating a user position in a WLAN positioning system based on user assigned access point locations
 * \li Jan 6, 2009: US Patent 7474897: Continuous data optimization by filtering and positioning systems
 * \li Feb 17, 2009: US Patent 7493127: Continuous data optimization of new access points in positioning systems
 * \li Mar 10, 2009: US Patent 7502620: Encoding and compression of a location beacon database
 * \li Apr 7, 2009: US Patent 7515578: Estimation of positioning using WLAN access point radio propagation characteristics in a WLAN positioning system
 * \li July 23, 2009: US Patent 7551579: Calculation of quality of WLAN access point characterization for use in a WLAN positioning system
 * \li July 23, 2009: US Patent 7551929: Estimation of speed and direction of travel in a WLAN positioning system using multiple position estimations
 * \li Nov 30, 2009: Singapore Patent 132039: Location beacon database and server, method of building location beacon database, and location based service using same
 * \li Mar 31, 2010: Singapore Patent 157355: Location beacon database and server, method of building location beacon database, and location based service using same
 * \li Aug 3, 2010: US Patent 7768963: System and method of improving sample of WLAN packet information to improve Doppler frequency of a WLAN positioning device
 * \li Aug 3, 2010: US Patent 7769396: Location-based services that choose location algorithms based on number of detected access points within range of a user device
 * \li Oct 19, 2010: US Patent 7818017: Location-based services that choose location algorithms based on number of detected access points within range of a user device
 * \li Nov 16, 2010: US Patent 7835754: Estimation of speed and direction of travel in a WLAN positioning system.
 * \li Nov 17, 2010: China Patent 2005800421832: Location beacon database and server, method of building location beacon database, and location-based service using same
 * \li Dec 21, 2010: US Patent 7856234: System and method for estimating positioning error within a WLAN-based positioning system.
 * \li Mar 15, 2011: Australia Patent 2010/226912: Continuous Data Optimization in Positioning System
 * \li Mar 29, 2011: US Patent 7916661: Estimation of position using WLAN access point radio propagation characteristics in a WLAN positioning system.
 * \li July 23, 2011: Australia Patent 2006/335359: Continuous Data Optimization in Positioning System
 * \li Aug 16, 2011: US Patent 7999742: System and method for using a satellite positioning system to filter WLAN access points in a hybrid positioning system
 * \li Sept 6, 2011: US Patent 8014788: Estimation of speed of travel using the dynamic signal strength variation of multiple WLAN access points
 * \li Sept 13, 2011: US Patent 8019357: System and method for estimating positioning error within a WLAN-based positioning system
 * \li Sept 20, 2011: US Patent 8022877: Systems and methods for using a satellite positioning system to detect moved WLAN access points
 * \li Oct 4, 2011: US Patent 8031657: Server for updating location beacon database
 * \li Oct 5, 2011: European Patent 2012830: Estimation of Speed and Direction of Travel in a WLAN Positioning System
 * \li Oct 27, 2011: Australia Patent 2005330513: Location beacon database and server, method of building location beacon database, and location-based service using same
 * \li Nov 8, 2011: US Patent 8054219: Systems and methods for determining position using a WLAN-PS estimated position as an initial position in a hybrid positioning system
 * \li Nov 15, 2011: Singapore Patent 152385: Systems and methods for estimating positioning error within a WLAN-based positioning system
 * \li Nov 18, 2011: Japanese Patent 4866361: Location Beacon Database and Server Method of Building Location Beacon Database Using Same
 * \li Nov 22, 2011: US Patent 8063820: Methods and systems for determining location using a hybrid satellite and WLAN positioning system by selecting the best SPS measurements
 * \li Dec 1, 2011: Australia Patent 2007/317677: System and Method for Estimating Positioning Error Within a WLAN Based Positioning System
 * \li Dec 14, 2011: European Patent 2022281: Calculation of Quality of a WLAN Access Point Characterization for Use in a WLAN Positioning System
 * \li Jan 3, 2012: US Patent 8089398: Methods and systems for stationary user detection in a hybrid positioning system
 * \li Jan 3, 2012: US Patent 8089399: System and method for refining a WLAN-PS estimated location using satellite measurements in a hybrid positioning system
 * \li Jan 3, 2012: US Patent 8090386: Estimation of speed and direction of travel in a WLAN positioning system
 * \li Jan 24, 2012: US Patent 8103288: Estimation of speed and direction of travel in a WLAN positioning system using multiple position estimations
 * \li March 6, 2012: US Patent 8130148: System and method for using a satellite positioning system to filter WLAN access points in a hybrid positioning system.
 * \li March 20, 2012: US Patent 8140094: Data optimization of new access points in positioning systems.
 * \li March 27, 2012: US Patent 8144673: Method and System for Employing a Dedicated Device for Position Estimation by a WLAN Positioning System.
 * \li April 10, 2012: US Patent 8154454: Systems and methods for using a satellite positioning system to detect moved WLAN access points link.
 * \li April 10, 2012: US Patent 8155673: Estimation of position using WLAN access point radiopropagation characteristics in a WLAN positioning system.
 * \li April 10, 2012: US Patent 8155666: Methods and systems for determining location using a cellular and WLAN positioning system by selecting the best cellular positioning system solution.
 * \li April 26, 2012: Australia Patent 2010/226917: Continuous Data Optimization in Positioning System
 * \li April 27, 2012: Japanese Patent 4980247: Continuous Data Optimization in Positioning System
 * \li May 22, 2012: US Patent 8185129: System and method of passive and active scanning of WLAN-enabled access points to estimate position of a WLAN positioning device.
 * \li July 17, 2012: US Patent 8223074: Systems and Methods for Using a Satellite Positioning System to Detect Moved WLAN Access Points.
 * \li July 24, 2012: US Patent 8229455: System and method of gathering and caching WLAN packet information to improve position estimates of a WLAN positioning device.
 * \li Aug 14, 2012: US Patent 8242960: Systems and methods for using a satellite positioning system to detect moved WLAN access points.
 * \li Aug 14, 2012: US Patent 8244272: Continuous data optimization of moved access points in positioning systems.
 * \li Oct 2, 2012: US Patent 8279114: Method of determining position in a hybrid positioning system using a dilution of precision metric.
 * \li Oct 9, 2012: US Patent 8284103: Systems and methods for using a satellite positioning system to detect moved WLAN access points.
 * \li Nov 20, 2012: US Patent 8315233: System and method of gathering WLAN packet samples to improve position estimates of WLAN positioning device.
 * \li Feb 5, 2013: US Patent 8369264: Method and System for Selecting and Providing a Relevant Subset of WI-FI Location Information to a Mobile Client Device so the Client Device may Estimate its Position with Efficient Utilization of Resources.
 * \li Mar 26, 2013: US Patent 8406785: Method and system for estimating range of mobile device to wireless installation.
 * \li June 11, 2013: US Patent 8462745: Methods and systems for determining location using a cellular and WLAN positioning system by selecting the best WLAN PS solution.
 * \li July 2, 2013: US Patent 8478297: Continuous data optimization of moved access points in positioning systems.
 * \li Sept 3, 2013: US Patent 8526967: Estimation of speed and direction of travel in a WLAN Positioning System.
 * \li Sept 17, 2013: US Patent 8538457: Continuous data optimization of moved access points in positioning systems.
 * \li September 18, 2013: Japanese Patent 5291618: Methods of filtering and determining cofidence factors for reference points for use in triangulation systems based on Wi-Fi access points.
 * \li October 15, 2013: US Patent 8559974: Methods of and systems for measuring beacon stability of wireless access points.
 * \li October 22, 2013: US Patent 8564481: Systems and Methods for Using a Satellite Positioning System to Detect Moved WLAN Access Points.
 * \li December 10, 2013: US Patent 8606294: Method of and System for Estimating Temporal Demographics of Mobile Users.
 * \li December 12, 2013: Australian Patent 2008345574: Providing Wi-Fi location information to a mobile device in order to estimate its position.
 * \li December 31, 2013: US Patent 8619643: System and Method for Estimating the Probability of Movement of Access Points in a WLAN-based Positioning System.
 * \li January 14, 2014: US Patent 8630664: Creation of an access point database.
 * \li January 14, 2014: US Patent 8630657: Systems for and methods of determing likelihood of reference point identify duplication in a positioning system.
 * \li January 28, 2014: US Patent 8638725: Methods and systems for determing location using a cellular and WLAN positioning system by selecting the best WLAN PS solution.
 * \li January 28, 2014: US Patent 8644852: Improvement of the accuracy and performance of a hybrid positioning system.
 * \li February 4, 2014: US Patent 8644852: Method and system for determining location using a hybrid satellite and WLAN positioning system by selecting the best WLAN-PS solution.
 * \li February 19, 2014: Japanese Patent 5419891.
 * \li March 26, 2014: Japanese Patent 5450689: Continuous data optimization in positioning systems.
 * \li March 26, 2014: Japanese Patent 5450529: Location beacon database and server, method of building location beacon database, and location based service using the same.
 * \li April 15, 2014: US Patent 8700053: System for and methods of determing likelikood of relocation of reference points in a positioning system.
 * \li April 22, 2014: US Patent 8706140: System and Method of Passive and Active Scanning of WLAN-Enabled Access Points to Estimate Position of a WLAN Positioning Device.
 * \li May 1, 2014: Australian Patent 2012200417: Method and system for determining location using a hybrid satellite and WLAN positioning system by selecting the best WLAN-PS solution.
 *
 *
 * \see http://www.skyhookwireless.com/patents/
 *
 * \page license Limited Use License
 *
 * Copyright (C) 2005-2013 Skyhook, Inc. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted subject to the following:
 *
 * * Use and redistribution is subject to the Software License and Development
 * Agreement, available at
 * <a href="http://www.skyhookwireless.com">www.skyhookwireless.com</a>
 *
 * * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#import "SHXAcceleratorDelegate.h"
#import "SHXCampaignDelegate.h"
#import <CoreLocation/CLLocation.h>
#import <Foundation/Foundation.h>

@class SHXPersona;
@class SHXIPLocation;

/**
 * Skyhook Accelerator
 *
 * The Context Accelerator SDK is thread-safe, so its API methods can safely
 * be called from any thread, but note that it will always call the methods of
 * your delegate from the main thread regardless of which thread your app uses
 * to call accelerator.
 */
@interface SHXAccelerator : NSObject <SHXCampaignDelegate>

/**
 * The delegate object to receive update events.
 */
@property (weak, atomic) id <SHXAcceleratorDelegate> delegate;

/**
 * The Skyhook persona.
 */
@property (atomic, readonly) SHXPersona *persona;

/**
 * Whether all campaigns are currently being monitored or not.
 */
@property (atomic, readonly, getter=isMonitoringAllCampaigns)
    BOOL monitoringAllCampaigns;

/**
 * The set of campaigns currently being monitored from calls to
 * startMonitoringForCampaign. This will be empty if no campaigns are being
 * monitored. It will also be empty if monitoringAllCampaigns is YES.
 *
 * This is a collection of NSString.
 */
@property (atomic, readonly) NSSet *monitoredCampaigns;

/**
 * The set of venues that the user is currently inside. In many cases there
 * will be at most one entry in this set, but it is possible for there to be
 * more than one in cases where venues are overlapping or close to each other.
 *
 * This is a collection of SHXCampaignVenue.
 */
@property (atomic, readonly) NSSet *currentVenues;

/*
 * It is required to use initWithKey:
 */
-(id)init __attribute__((unavailable("use initWithKey:")));

/**
 * Initialize a new object.
 *
 * \param key the activator key.
 *
 * \exception NSInvalidArgumentException if key is nil or empty
 * \exception SHXIllegalStateException if key is different from the one used
 *                                     in any other SHXAccelerator instance
 */
- (id)initWithKey:(NSString *)key;

/**
 * Starts monitoring for all campaigns that are active in the portal. This
 * affects all accelerator objects in your application.
 *
 * Campaign events are delivered to the accelerator:didEnterVenue: and
 * accelerator:didExitVenue: methods of your delegate. If there is an error,
 * accelerator calls the accelerator:didFailWithError: method of your
 * delegate.
 *
 * If a campaign venue enter or exit event occurs while your app is not
 * running, the system automatically wakes it up (or relaunches it) in the
 * background so that it can process the event. In addition, creating a new
 * accelerator instance and assigning a delegate results in the delivery of
 * the corresponding campaign messages. Upon relaunch, you must at the very
 * least create an accelerator object in order to continue receiving campaign
 * monitoring events.
 *
 * If all campaigns are currently being monitored, then this method has no
 * effect.
 */
- (void)startMonitoringForAllCampaigns;

/**
 * Stops monitoring for all campaigns for all accelerator objects in your
 * application.
 *
 * If no campaigns are currently being monitored, then this method has no
 * effect.
 */
- (void)stopMonitoringForAllCampaigns;

/**
 * Starts monitoring the specified campaign.
 *
 * This method is needed only in cases where fine control of the active
 * campaigns is necessary, and in that case you must call it separately for
 * each campaign you want to monitor. In most cases
 * startMonitoringForAllCampaigns should be used instead to enable monitoring
 * for all campaigns that are active in the portal. The campaigns you add
 * using this method are shared by all accelerator objects in your application
 * and stored in the monitoredCampaigns property. Note that a call to
 * stopMonitoringForAllCampaigns from any accelerator object in your
 * application will stop the monitoring for all campaigns including those
 * started by a call to this method.
 *
 * The events are delivered to the delgegates using the same methods that
 * startMonitoringForAllCampaigns uses, and your app will be woken up (or
 * relaunched) if an event occurs when it is not running.
 *
 * If the specified campaign is currently being monitored, or if all campaigns
 * are currently being monitored, then this method has no effect. If a
 * campaign is specified which is not active on the portal, then it will be
 * silently ignored.
 *
 * \param campaignName the name of the campaign to start monitoring.
 *
 * \exception NSInvalidArgumentException if campaignName is nil or empty
 */
- (void)startMonitoringForCampaign:(NSString *)campaignName;

/**
 * Stops monitoring the specified campaign. This affects all accelerator
 * objects in your application.
 *
 * If the specified campaign is not currently being monitored, then this
 * method has no effect. Note that if all campaigns are being monitored, then
 * calling this method has no effect. It will not stop the specified campaign
 * from being monitored.
 *
 * \param campaignName the name of the campaign to stop monitoring.
 *
 * \exception NSInvalidArgumentException if campaignName is nil or empty
 */
- (void)stopMonitoringForCampaign:(NSString *)campaignName;

/**
 * Tells accelerator that new location data is available.
 *
 * This can be used both to improve campaign monitoring and as an optimization
 * for any of the API methods that need the current location, such as
 * refreshPersona, fetchNearbyMonitoredVenuesWithLimit, and
 * fetchVenueInfoAtLocationWithCompletion. For best results pass all locations
 * determined by the app to this method.
 *
 * \param location the location data.
 */
- (void)didUpdateToLocation:(CLLocation *)location;

/**
 * Refresh the Skyhook persona.
 *
 * \param completion a completion block to be called when done. On success,
 *                   persona will contain the updated persona,
 *                   error will be nil, and the persona property will be
 *                   updated. On error, persona will be nil, error
 *                   will contain the error object, and the persona property
 *                   will be unchanged.
 */
- (void)refreshPersonaWithCompletion:(void (^)(SHXPersona *persona, NSError *error))completion;

/**
 * Determines location using IP address.
 *
 * \param completion a completion block to be called when done. On success,
 *                   location will contain a valid location and error will be
 *                   nil. On error, location will be nil and error will
 *                   contain the error object.
 */
- (void)requestIPLocationWithCompletion:(void (^)(SHXIPLocation *location, NSError *error))completion;

/**
 * Set whether or not accelerator should collect usage information to continually
 * improve the quality of the returned Skyhook personas. The SDK does not
 * track individual users and completely anonymizes all collected
 * information.
 *
 * Note that you might receive degraded personas if usage
 * collection is disabled.
 *
 * The default is that usage collection is enabled.
 *
 * Note that if the application doesn't use the iOS Ad Support framework,
 * or the "Limit Ad Tracking" system setting is enabled, accelerator
 * will not collect usage information even if the preference
 * to collect data is set to YES.
 */
+ (void)setUsageCollectionEnabled:(BOOL)usageCollectionEnabled;
+ (BOOL)isUsageCollectionEnabled;

/**
 * Set whether or not accelerator is allowed to cause the system to prompt the
 * user to ask whether location services can be used.
 *
 * The default is that the prompt is allowed. In order for this to take effect
 * it must be called before the first call to startMonitoringForAllCampaigns
 * or startMonitoringForCampaign.
 */
+ (void)setLocationPromptAllowed:(BOOL)promptAllowed;
+ (BOOL)isLocationPromptAllowed;

/**
 * Set the number of iOS Core Location Regions reserved by the rest of app,
 * leaving the remainder to be used for campaign monitoring.
 *
 * The default value is zero meaning that all of the regions can be used for
 * campaign monitoring. The value specified for this must leave at least three
 * regions for campaign monitoring which means that the maximum value allowed
 * is 17 as of iOS version 8. For best results use as low a value as
 * possible. In order for this to take effect it must be called before the
 * first call to startMonitoringForAllCampaigns or startMonitoringForCampaign.
 */
+ (void)setNumRegionsReserved:(NSUInteger)numRegions;
+ (NSUInteger)numRegionsReserved;

/**
 * Returns the Accelerator SDK version.
 *
 * \return a string containing the version information as
 *         <major>.<minor>.<revision>.<build>
 */
+ (NSString *)version;

/**
 * Fetch the list of venues nearby the current location for campaigns that are
 * being monitored.
 *
 * \param limit maximum number of entries fetched. The maximum value allowed
 *              for this is 100.
 * \param completion a completion block to be called when done. On success,
 *                   venues will contain an array of SHXNearbyCampaignVenue,
 *                   ordered from closest to farthest. On error, venues will
 *                   be nil and error will contain the error object.
 */
- (void)fetchNearbyMonitoredVenuesWithLimit:(NSUInteger)limit
                                 completion:(void (^)(NSArray *venues, NSError *error))completion;

/**
 * Fetch information for a list of venues.
 *
 * \param venues an array of venue IDs as NSNumbers. At most only the first
 *               100 entries of this list will be used.
 * \param completion a completion block to be called when done. On success,
 *                   venueInfo will contain an array of SHXVenueInfo, in no
 *                   particular order. IDs that are not valid or for which
 *                   there is no information will be omitted from the list. On
 *                   error, venueInfo will be nil and error will contain the
 *                   error object.
 */
- (void)fetchInfoForVenues:(NSArray *)venues
                completion:(void (^)(NSArray *venueInfo, NSError *error))completion;

/**
 * Fetch information for the venues at the current location.
 *
 * This will pass back the information for the venues at the current location
 * even if those venues are not currently being monitored in any campaign. At
 * most 10 venues will be passed back.
 *
 * If there is no recent location, either from a call to didUpdateToLocation:
 * or as determined by accelerator for campaign monitoring, then a location
 * will be calculated first before fetching the venue information.
 *
 * If this method is called while a previous call is already in progress, then
 * that existing operation will be aborted and its completion block will be
 * invoked with an SHXErrorAborted.
 *
 * \param completion a completion block to be called when done. On success,
 *                   venues will contain an array of SHXVenueInfo, ordered
 *                   approximately from closest to farthest. On error,
 *                   venueInfo will be nil and error will contain the error
 *                   object.
 */
- (void)fetchVenueInfoAtLocationWithCompletion:(void (^)(NSArray *venueInfo, NSError *error))completion;

/**
 * Fetch the list of recent campaign visits.
 *
 * \param limit maximum number of entries fetched. The maximum value allowed
 *              for this is 100.
 * \param completion a completion block to be called when done. On success,
 *                   visits will contain an array of SHXCampaignVisit,
 *                   ordered from most recent to least recent enter time. On
 *                   error, visits will be nil and error will contain the
 *                   error object.
 */
- (void)fetchRecentCampaignVisitsWithLimit:(NSUInteger)limit
                                completion:(void (^)(NSArray *visits, NSError *error))completion;

@end
